---
layout: post
title: "dynamic programming algorithm"
date: 2022-10-24 00:00:00 +0900
tag: data structure
background: "/img/bg-post.jpg"
---

## 다이나믹 프로그래밍 (동적 계획법)

- 다이나믹 프로그래밍은 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법
- 이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 한다
- 다이나믹 프로그래밍의 구현은 일반적으로 두가지 방식(탑다운과 버텀업)으로 구성된다


### 다이나믹 프로그래밍의 조건

1. 최적 부분 구조 (Optimal Substructure)
    - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다

2. 즁복되는 부분 문제 (Overlapping Subproblem)
    - 동일한 작은 문제를 반복적으로 해결

### 피보나치 수열

- 다이나믹 프로그래밍으로 효과적으로 계산할 수 있다

피보나치 수열: 단순 재귀 소스코드 (python)

```python

    def fibo(x):
        if x == 1 or x == 2:
            return 1
        return fibo(x-1) + fibo(x-2)

    print(fibo(4))

```

### 피보나치 수열의 시간 복잡도 분석

- 단순 재귀 함수로 피보나치 수열을 해결하면 지수 시간 복잡도를 가지게 된다
    - 중복 되는 문제가 있기 때문
- 피보나치 수열의 시간 복잡도 -> O(2^N)

### 피보나치 수열의 효율적인 해법: 다이나믹 프로그래밍

- 최적 부분 구조: 큰 문제를 작은 문제로 나눌 수 있는가
- 중복되는 부분 문제: 동일한 작은 문제를 반복적으로 해결
- 피보나치 수열은 두개의 다이나믹 프로그래밍 사용조건 만족

### 메모이제이션 (Memoization)

- 메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 하나
- 한 번 계산한 결과를 메모리 공간에 메모하는 기법
    - 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옴
    - 값을 기록해 놓는다는 점에서 캐싱(Caching)이라고도 한다

### Top down VS Bottom up

- 탑다운(메모이제이션) 방식은 하향식이라고도 하며 보텀업 방식은 상향식이라고도 합니다
- 다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식
    - 결과 저장용 리스트는 DP 테이블이라고 부른다
- 엄밀히 말하면 메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미
    - 따라서 메모이제이션은 다이나믹 프로그래밍에 국한된 개념은 아니다
    - 한 번 계산된 결과를 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있다


피보나치 수열: 탑다운 다이나믹 프로그래밍 소스코드 (python)

```python

    # 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화
    d = [0] * 100

    # 피보나치 함수를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
    def fibo(x):
        # 종료 조건 (1 혹은 2일 때 1을 반환)
        if x == 1 or x == 2:
            return 1
        
        # 이미 계산한 적 있는 문제라면 그대로 반환
        if d[x] != 0:
            return d[x]

        # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
        d[x] = fibo(x-1) + fibo(x-2)
        return d[x]

    print(fibo(99))

```

피보나치 수열: 보텀업 다이나믹 프로그래밍 소스코드 (python)

```python

    # 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
    d = [0] * 100

    # 첫 번째 피보나치 수와 두번째 피보나치 수는 1
    d[1] = 1
    d[2] = 1
    n = 99

    # 피보나치 함수 반복문으로 구현
    for i in range(3, n+1):
        d[i] = d[i-1] + d[i-2]

    print(d[n])

```

- 메모이제이션을 이용하는 경우 피보나치 수열 함수의 시간 복잡도는 O(N)이다

### 다이나믹 프로그래밍 문제에 접근하는 방법

- 주어진 문제가 다이나믹 프로그래밍 유형임을 파악하는 것이 중요
- 그리디, 구현, 완전 탐색 등의 아이디어로 문제를 해결할 수 있는지 검토
    - 다른 알고리즘으로 풀이 방법이 떠오르지 않으면 다이나믹 프로그래밍을 고려
- 일단 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤에 (탑다운) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면, 코드를 개선하는 방법을 사용할 수 있다
- 일반적인 코딩 테스트 수준에서는 기본 유형의 다이나믹 프로그래밍 문제가 출제되는 경우가 많다

### <문제> 개미 전사

내가 짠 코드

```python

    n = int(input())

    k = list(map(int, input().split()))

    odd_total = 0
    even_total = 0
    for i in range(n):
        if i % 2 == 0:
            even_total += k[i]
        else:
            odd_total += k[i]

    if odd_total > even_total:
        print(odd_total)
    else:
        print(even_total)

```

정답 예시 코드

```python

    # 정수 n을 입력받기
    n = int(input())

    # 모든 식량 정보 입력 받기
    array = list(map(int, input().split()))

    # 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
    d = [0] * 100

    # 다이나믹 프로그래밍 진행
    d[0] = array[0]
    d[1] = max(array[0], array[1])
    for i in range(2, n):
        d[i] = max(d[i-1], d[i-2] + array[i])

    # 계산된 결과 출력
    print(d[n-1])

```

### <문제> 1로 만들기

- 피보나치 수열 문제를 도식화한 것처럼 함수가 호출되는 과정을 그림으로 그려보면 이해가 빠르다
- 최적 부분 구조와 중복되는 부분 문제를 만족

```python

    n = int(input())

    # 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
    d = [0] * 30001

    # 다이나믹 프로그래밍 진행
    for i in range(2, n+1):
        # 현재의 수에서 1을 빼는 경우
        d[i] = d[i-1] + 1

        # 현재의 수가 2로 나누어 떨어지는 경우
        if i % 2 == 0:
            d[i] = min(d[i], d[i//2] + 1)
        # 현재의 수가 3으로 나누어 떨어지는 경우
        if i% 3 == 0:
            d[i] = min(d[i], d[i//3]+1)
        # 현재의 수가 5로 나누어 떨어지는 경우
        if i%5 == 0:
            d[i] = min(d[i], d[i//5]+1)

    print(d[n])

```
- 다이나믹 프로그래밍 문제는 일단 전의 값을 담아둘 수 있는 배열을 만들고 그것을 활용하는 방법으로 접근하는 것이 중요하다

### <문제> 효율적인 화폐 구성

- a = 금액 i를 만들 수 있는 최소한의 화폐 개수
- k = 각 화폐의 단위

```python

    n, m = map(int, input().split())

    # N개의 화폐 단위 정보를 입력받기
    array = []
    for i in range(n):
        array.append(int(input()))

    # 한 번 계산된 결과를 저장하기 위한 DP 테이블 초기화
    d = [10001] * (m+1)

    # 다이나믹 프로그래밍 진행
    d[0] = 0
    for i in range(n):
        for j in range(array[i], m+1):
            if d[j - array[i]] != 10001:
                d[j] = min(d[j], d[j - array[i]] + 1)

    # 계산된 결과 출력
    if d[m] == 10001:
        print(-1)
    else:
        print(d[m])

```

### <문제> 금광

- 현재 다이나믹 프로그래밍이 어떤 것인지 확 와닿지가 않는다
- 일단 문제를 풀어보며 더 감을 잡을 수 있도록 해본다

- 금광의 모든 위치에 대하여 3가지만 고려하면 된다
    - 왼쪽 위에서 오는 경우
    - 왼쪽 아래에서 오는 경우
    - 왼쪽에서 오는 경우

- 세 가지 경우 중에서 가장 많은 금을 가지고 있는 경우를 테이블에 갱신해주어 문제를 해결

- array[i][j] = i행 j열에 존재하는 금의 양
- dp[i][j] = i행 j열까지의 최적의 해 (얻을 수 있는 금의 최댓값)
- 테이블에 접근할 때마다 리스트의 범위를 벗어나지 않는지 체크해야한다
- 편의상 초기 데이터를 담는 변수 array를 사용하지 않아도 된다
    - 바로 DP 테이블에 초기 데이터를 담아서 다이나믹 프로그래밍을 적용할 수 있다

```python

    # 테스트 케이스 입력
    for tc in range(int(input())):
        # 금광 정보 입력
        n, m = map(int, input().split())
        array = list(map(int, input().split()))

        # 다이나믹 프로그래밍을 위한 2차원 DP 테이블 초기화
        dp = []
        index = 0
        for i in range(n):
            dp.append(array[index:index+m])
            index += m

        # 다이나믹 프로그래밍 진행
        for j in range(1, m):
            for i in range(n):
                # 왼쪽 위에서 오는 경우
                if i == 0: left_up = 0
                else: left_up = dp[i-1][j-1]

                # 왼쪽 아래에서 오는 경우
                if i == n-1: left_down = 0
                else: left_down = dp[i+1][j-1]

                # 왼쪽에서 오는 경우
                left = dp[i][j-1]
                dp[i][j] = dp[i][j] + max(left_up, left_down, left)

        result = 0
        for i in range(n):
            result = max(result, dp[i][m-1])

        print(result)

```

- 다이나믹 프로그래밍 => 일단 전의 값을 담아줄 수 있는 array를 만들어 접근하는 방식이다 까지만 이해가 가는 상황 만든 테이블을 어떻게 활용하거나 이용하는지는 아직 방법을 잘 모르겠다
문제를 풀어보면서 계속 이해해가는 수밖에 없을 것 같다

### <문제> 병사 배치하기

- 문제의 기본 아이디어는 가장 긴 증가하는 부분 수열로 잘 알려진 전형적인 다이나믹 프로그래밍 문제의 아이디어와 같다
- 예를 들어 하나의 수열 array = {4,2,5,8,4,11,15}
- 본 문제는 가장 긴 감소하는 부분 수열을 찾는 문제로 치환할 수 있으므로, LIS 알고리즘을 조금 수정하여 적용함으로써 정답을 도출할 수 있다


- 먼저 입력 받은 병사 정보의 순서를 뒤집는다
- 가장 긴 증가하는 부분 수열 (LIS) 알고리즘을 수행하여 정답을 도출합니다

```python

    n = int(input())
    array = list(map(int, input().split()))

    # 순서를 뒤집어 최장 증가 부분 수열 문제로 ㅂㄴ환
    array.reverse()

    # 다이나믹 프로그래밍을 위한 1차원 DP 테이블 초기화
    dp = [1] * n

    # 가장 긴 증가하는 부분 수열(LIS) 알고리즘 수행
    for i in range(1, n):
        for j in range(0, i):
            if array[j] < array[i]:
                dp[i] = max(dp[i], dp[j] + 1)

    # 열외해야 하는 병사의 최소 수를 출력
    print(n - max(dp))

```